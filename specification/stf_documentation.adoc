= STF: Documentation
Mars <mars@squirrel.pub>
v0.0.0
:hardbreaks-option:
:toc:

**Squirrel Transfer Format - Modular 3D Interchange Format** [version {revnumber}]

Intended for (not only) game development use-cases.

== Introduction

A STF file consists of a binary header, a Json definition, and zero or more binary buffers.

By itself, STF is merely a 'shell' format. Actual content is stored in objects defined by their type.
The minimum required set of types is defined in this document in the **link:./stf_default_types.adoc[Default Types Specification]**.

STF implementations must provide an easy to use plugin system, and if in any way possible, the ability to hot-load plugins.

Objects of any type get referenced by a globally/universally unique ID as a string. This will be reffered to as `ID`.

The file extension is `.stf`.
The media-type is `model/stf`.
The STF binary header is stored in `little endian` byte order.
The Json definition is encoded as `utf8`.
By default, binary buffers are stored in `little endian` byte order.
By default, STF uses the same coordinate system as glTF 2.0. (See https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#coordinate-system-and-units[glTF-2.0. coordinate-system-and-units])

== Binary Format

[%autowidth, %header,cols=2*]
|===
|Length (Bytes) |Content
|4 | Magic number: `STF0`
|4 | STF binary format version major
|4 | STF binary format version minor
|4 | Number of buffers, including the Json definiton buffer
|8 * {number of buffers} | Buffer length in bytes
|{number of buffers} * {buffer length} | The buffers
|===

The Json definition is the first and only required buffer.

== Json Definition
The root Json element is an `object`. It contains 3 properties: `stf`, `resources` and `buffers`.

=== The 'stf' object
The `stf` object holds meta information.

.`stf` object Properties:
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|version_major |Yes |Integer |Major version of STF
|version_minor |Yes |Integer |Minor version of STF
|root |Yes |ID |ID of the root resource
|profiles |No |List<String> |List of profile this asset adheres to. These are a set of
|===

The root resource must be of the `stf.prefab` type. It represents the entire assets scene hierarchy and has a single root node.

.Example Json Metadata
[%collapsible]
====
.STF object example
[,json]
----
"stf": {
	"version_major": 0,
	"version_minor": 0,
	"meta": {
		"asset_name": "STF Example 1",
	},
	"profiles": [
		"node_names_unique_within_prefab",
		"game_engine_wide_compatibility",
		"max_4_weights_per_vertex",
		"no_prefab_instances"
	]
	"root": "5f1ea7e8-ee26-46c9-91dc-cd002cb9b0a5"
}
----
====

=== The 'resources' object
The `resources` object is a map of resource objects identified by an ID.

The various resource objects describe the files actual content. Each resource has a `type` property and optional lists of references to other resources and buffers. Any further properties are defined in the resource-type's definition.

.Resource object general properties:
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|type |Yes |String |Namespaced type name of the resource
|referenced_resources |No |List<ID> |IDs of Resources this resource depends on
|referenced_buffers |No |List<ID> |IDs of Buffers this resource depends on
|name |No |String |Display name of the resource
|degraded |No |Boolean |Has this resource lost information at some point, but retained the same ID
|===

Resources may contain other resources. The top most resource is exclusively responsible for storing references to other resources and buffers. The top most resource, as well as any sub-resource must reference resources and buffers by index in the top most resource's reference property.

Resources can be Data, Scene Hierarchy, Node, Component and Modification types.
Each of these kinds has additional general properties.

Find the list of all specified default resource-types in the **link:./stf_default_types.adoc[Default Types Specification]**.

==== Data Resources
Can exist only at the top level.
Loading plugins of this kind must be supported.

.Data Resource Properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|fallback |No |ID |ID of a resource that should be used in case this one's type is not supported in this implementation
|components |No |Map<ID, Component> |
|===

==== Scene Hierarchy Resources
Can exist only at the top level. Represents a scene hierarchy, made up of `Node` kinds
Loading plugins of this kind must be supported

.Scene Hierarchy Resource Properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|root |ID |ID | The ID of the root node contained in this resource
|nodes |No |Map<ID, Node> |
|===

==== Node Resources
Can only exist within a `Scene Hierarchy` kind type.
Loading plugins of this kind is not required.

.Node Resource Properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|children |No |Map<ID, Node> |
|components |No |Map<ID, Component> |
|===

==== Component Resources
Represents functionality or information of `Data` or `Node` kinds.
Loading plugins of this kind must be supported.

.Component Resource Properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|overrides |No |List<ID> |References `Component` kind types that should not be processed, if this type is supported
|===

==== Modification Resources
They are a special type that can exist only on instantiations of `Scene Hierarchy` kind types. For example on `stf.instance.prefab` and `stf.instance.armature`.
Represents a change to be applied onto the elements of a referenced `Scene Hierarchy` kind.
Loading plugins of this kind is not required.

==== Examples

`stf.image` is a `Data` kind type. Types that are a kind of `Data` can only exist at the top level.
`stf.node.spatial` is a `Node` kind type. `Node` kind types can only exist within `Scene Hierarchy` kinds.

Combinations of 'kinds' of resource types can exist. For example an armature is a `Data` and `Scene Hierarchy` kind of type.

The information about what `kind` a type is must be known by a type's implementation and is not containes within a STF files. This should be used to validate files.

.Example Json Resources
[%collapsible]
====
.resources object example
[,json]
----
"resources": {
	"b5f96f63-d5ce-4210-b4d6-8f43fbf557dd": {
		"type": "stf.material",
		"name": "Body Material",
		"referenced_resources": [
			"6f03d810-4613-467d-921b-a5302552f9d5"
		],
		"properties": {
			"albedo": {
				"type": "image",
				"image": 0
			},
		}
	},
	"6f03d810-4613-467d-921b-a5302552f9d5": {
		"type": "stf.image",
		"name": "Body_Albedo",
		"image_format": "png",
		"texture_type": "rgb"
	},
}
----
====

=== The 'buffers' object
The `buffers` object is a map of buffer objects identified by an ID.
Each buffer object has a `type` property. Any further properties are defined in the buffer-type's definition.

In a binary STF file, `stf.buffer.included` is the only supported buffer type.
In a `stf.json` file, `stf.buffer.file` is the only supported buffer type.
Supporting buffer plugins is not required.

.Example Json Buffers in an STF binary File
[%collapsible]
====
.buffers object example in an STF binary file
[,json]
----
"buffers": {
	"2c04d7f9-96cd-4867-baf3-2a54d4d31a67": {
		"type": "stf.buffer.included",
		"index": 0
	}
}
----
====

.Example Json Buffers in a `stf.json` File
[%collapsible]
====
.buffers object example in an STF binary file
[,json]
----
"buffers": {
	"2c04d7f9-96cd-4867-baf3-2a54d4d31a67": {
		"type": "stf.buffer.file",
		"path": "./buffers/mesh.stfbuffer"
	}
}
----
====

==== Default Buffer Types
===== stf.buffer.included
This type represents a buffer contained in the same file.

.stf.buffer.included properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|index |Yes |Integer |Index of the binary buffer in the file
|===

=== Minimal Definition Example
.Show
[%collapsible]
====
[,json]
----
{
	"stf": {
		"version_major": 0,
		"version_minor": 0,
		"meta": {
			"asset_name": "STF Example 1"
		},
		"profiles": [
			"node_names_unique_within_prefab",
			"game_engine_wide_compatibility",
			"max_4_weights_per_vertex",
			"no_prefab_instances"
		],
		"root": "5f1ea7e8-ee26-46c9-91dc-cd002cb9b0a5"
	},
	"resources": {
		"5f1ea7e8-ee26-46c9-91dc-cd002cb9b0a5": {
			"type": "stf.prefab",
			"referenced_resources": ["0e2e767b-2f90-4739-ad78-486b378ba051"]
			"root": "1e5775b8-64ae-4cfa-b8dd-ad6a91469d95"
			"nodes": {
				"1e5775b8-64ae-4cfa-b8dd-ad6a91469d95": {
					"name": "Super Awesome Model",
					"enabled": true,
					"trs": [],
					"children": [],
					"components": {
						"2d172a76-e326-44d1-98c3-0c0ee2b15edd": {
							"type": "stf.instance.mesh",
							"enabled": true,
							"mesh": 0
						}
					}
				}
			}
		},
		"0e2e767b-2f90-4739-ad78-486b378ba051": {
			"type": "stf.mesh",
			"referenced_buffers": ["2c04d7f9-96cd-4867-baf3-2a54d4d31a67"]
			"vertex_count": 32000,
			"vertecies": {
				"format": "f32",
				"buffer": 0
			}
		}
	},
	"buffers": {
		"2c04d7f9-96cd-4867-baf3-2a54d4d31a67": {
			"type": "stf.buffer.included",
			"index": 0
		}
	}
}
----
====

== Profiles
Profiles define rules to which a STF file adheres to. Each STF implementation has to check each file on import and export whether it adheres to its set profiles.

STF defines a set of profiles, but implementations can support additional ones.

=== node_names_unique_within_prefab
=== game_engine_wide_compatibility
=== max_4_mesh_weights
=== no_prefab_instances

