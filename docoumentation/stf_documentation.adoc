// Licensed under CC-BY-4.0 (<https://creativecommons.org/licenses/by/4.0/>)

= STF: Documentation
Mars <mars@squirrel.pub>
v0.0.0
:homepage: https://github.com/emperorofmars/stf
:keywords: stf, 3d, fileformat, format, interchange, interoperability
:hardbreaks-option:
:library: Asciidoctor
:toc:
:toclevels: 4
:toc-placement!:
:idprefix:
:idseparator: -
:experimental:
:table-caption!:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]

**Squirrel Transfer Format - Modular 3D Interchange Format** [version {revnumber}]

Intended for (not only) game development use-cases.

toc::[]

== Introduction
An STF asset can be represented as a single binary file, or separated into multiple files.

By itself, STF is merely a 'shell' format. Actual content is stored in objects defined by their `type`.
The minimum required set of types is defined in this document.

STF implementations must provide an easy to use plugin system, and if in any way possible, the ability to hot-load plugins.

Objects of any type get referenced by a globally/universally unique ID as a string. This will be refered to as `ID`.

The file extension for stf binary files is `.stf`.
The file extension for stf json files is `.stf.json`.
The media-type for stf binary files is `model/stf+binary`.
The media-type for stf json files is `model/stf+json`.
The STF binary header is stored in `little endian` byte order.
The Json definition is encoded as `utf8`.
By default, binary buffers are stored in `little endian` byte order.
STF uses the same coordinate system as glTF 2.0. (See https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#coordinate-system-and-units[glTF-2.0. coordinate-system-and-units])

== Binary Format
A STF binary file consists of a binary header, a <<json-definition>>, and zero or more binary buffers.

.Binary file layout
[%autowidth, %header,cols=2*]
|===
|Length (Bytes) |Content
|4 | Magic number: `STF0`
|4 | STF binary format version major
|4 | STF binary format version minor
|4 | Number of buffers, including the Json definiton buffer
|8 * {number of buffers} | Buffer length in bytes
|{number of buffers} * {buffer length} | The buffers
|===

The Json definition is the first and only required buffer.

== Json Definition
The root Json element is an object. It contains 3 properties: `<<stf>>`, `<<resources>>` and `<<buffers>>`.

=== 'stf'
The `stf` object holds meta information.

.`stf` object properties:
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|version_major |Yes |Integer |Major version of STF
|version_minor |Yes |Integer |Minor version of STF
|root |Yes |ID |ID of the root resource
|profiles |No |List<String> |List of <<profiles, profiles>> this asset adheres to. These are a set of
|===

The root resource must be of the `<<stf-prefab>>` type. It represents the entire assets scene hierarchy and has a single root node.

.Example
[%collapsible]
====
.stf object example
[,json]
----
"stf": {
	"version_major": 0,
	"version_minor": 0,
	"meta": {
		"asset_name": "STF Example 1",
	},
	"profiles": [
		"compatibility_wide"
	]
	"root": "5f1ea7e8-ee26-46c9-91dc-cd002cb9b0a5"
}
----
====

=== 'resources'
The `resources` object is a map of resource objects identified by an ID.

The various resource objects describe the files actual content. Each resource has a `type` property and optional lists of references to other resources and buffers. Any further properties are defined in the resource-type's definition.

.Resource object general properties:
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|type |Yes |String |Namespaced type name of the resource
|referenced_resources |No |List<ID> |IDs of Resources this resource depends on
|referenced_buffers |No |List<ID> |IDs of Buffers this resource depends on
|name |No |String |Display name of the resource
|degraded |No |Boolean |Has this resource lost information at some point, but retained the same ID
|===

Resources may contain other resources. The top most resource is exclusively responsible for storing references to other resources and buffers. The top most resource, as well as any sub-resource must reference resources and buffers by index in the top most resource's reference property.

Resources can be `Data`, `Scene Hierarchy`, `Node`, `Component` and `Modification` kinds.
Each of these kinds has additional general properties.

==== Data
Can exist only at the top level.
Loading plugins of this kind must be supported.

.Data resource properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|fallback |No |ID |ID of a resource that should be used in case this one's type is not supported in this implementation
|components |No |Map<ID, Component> |
|===

==== Scene Hierarchy
Can exist only at the top level. Represents a scene hierarchy, made up of `Node` kinds.
Loading plugins of this kind must be supported

.Scene hierarchy resource properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|root |ID |ID | The ID of the root node contained in this resource
|nodes |No |Map<ID, Node> |
|===

==== Node
Can only exist within a `Scene Hierarchy` kinds.
Loading plugins of this kind is not required.

.Node resource properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|children |No |Map<ID, Node> |
|components |No |Map<ID, Component> |
|===

==== Component
Represents functionality or information of `Data` or `Node` kinds.
Loading plugins of this kind must be supported.

.Component resource properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|overrides |No |List<ID> |References `Component` kind types that should not be processed, if this type is supported
|===

==== Modification
They are a special kind that can exist only on instantiations of `Scene Hierarchy` kinds. For example on `<<stf-instance-prefab>>` and `<<stf-instance-armature>>`.
Represents a change to be applied onto the elements of a referenced `Scene Hierarchy` kind.
Loading plugins of this kind is not required.

==== Resource Composition Examples

`<<stf-image>>` is a `Data` kind. `Data` kinds can only exist at the top level.
`<<stf-node-spatial>>` is a `Node` kind. `Node` kinds can only exist within `Scene Hierarchy` kinds.

Combinations of these 'kinds' of resource types can exist. For example `<<stf-armature>>` is a `Data` and `Scene Hierarchy` kind.

The information about what `kind` a type is must be known by a type's implementation and is not contained in STF files. This information should be used to validate files.

.Example
[%collapsible]
====
.resources object example
[,json]
----
"resources": {
	"b5f96f63-d5ce-4210-b4d6-8f43fbf557dd": {
		"type": "stf.material",
		"name": "Body Material",
		"referenced_resources": [
			"6f03d810-4613-467d-921b-a5302552f9d5"
		],
		"properties": {
			"albedo": {
				"type": "image",
				"image": 0
			},
		}
	},
	"6f03d810-4613-467d-921b-a5302552f9d5": {
		"type": "stf.image",
		"name": "Body_Albedo",
		"image_format": "png",
		"texture_type": "rgb"
	},
}
----
====

=== 'buffers'
The `buffers` object is a map of buffer objects identified by an ID.
Each buffer object has a `type` property. Any further properties are defined in the buffer-type's definition.
Two types of buffers are defined. Supporting buffer plugins is not required.

In a binary STF file, `stf.buffer.included` is the only supported buffer type.

In a `stf.json` file, `stf.buffer.file` is the only supported buffer type.

==== stf.buffer.included
This type represents a buffer contained in the same file.

.stf.buffer.included properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|index |Yes |Integer |Index of the binary buffer in the file
|===

.Example
[%collapsible]
====
.buffers object example in an STF binary file
[,json]
----
"buffers": {
	"2c04d7f9-96cd-4867-baf3-2a54d4d31a67": {
		"type": "stf.buffer.included",
		"index": 0
	}
}
----
====

==== stf.buffer.file
This type represents a buffer contained in the same file.

.stf.buffer.file properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|path |Yes |String |Relative path to a buffer file.
|===

A `.stfbuffer` file starts with a magic number of `STFB`. The rest of the file is the raw buffer.

.Example
[%collapsible]
====
.buffers object example in an STF Json file
[,json]
----
"buffers": {
	"2c04d7f9-96cd-4867-baf3-2a54d4d31a67": {
		"type": "stf.buffer.file",
		"path": "./buffers/mesh.stfbuffer"
	}
}
----
====

=== Minimal Definition Example
.Show
[%collapsible]
====
[,json]
----
{
	"stf": {
		"version_major": 0,
		"version_minor": 0,
		"meta": {
			"asset_name": "STF Example 1"
		},
		"profiles": [
			"compatibility_wide"
		],
		"root": "5f1ea7e8-ee26-46c9-91dc-cd002cb9b0a5"
	},
	"resources": {
		"5f1ea7e8-ee26-46c9-91dc-cd002cb9b0a5": {
			"type": "stf.prefab",
			"referenced_resources": ["0e2e767b-2f90-4739-ad78-486b378ba051"]
			"root": "1e5775b8-64ae-4cfa-b8dd-ad6a91469d95"
			"nodes": {
				"1e5775b8-64ae-4cfa-b8dd-ad6a91469d95": {
					"name": "Super Awesome Model",
					"enabled": true,
					"trs": [],
					"children": [],
					"components": {
						"2d172a76-e326-44d1-98c3-0c0ee2b15edd": {
							"type": "stf.instance.mesh",
							"enabled": true,
							"mesh": 0
						}
					}
				}
			}
		},
		"0e2e767b-2f90-4739-ad78-486b378ba051": {
			"type": "stf.mesh",
			"referenced_buffers": ["2c04d7f9-96cd-4867-baf3-2a54d4d31a67"]
			"vertex_count": 32000,
			"vertecies": {
				"format": "f32",
				"buffer": 0
			}
		}
	},
	"buffers": {
		"2c04d7f9-96cd-4867-baf3-2a54d4d31a67": {
			"type": "stf.buffer.included",
			"index": 0
		}
	}
}
----
====

== Profiles
Profiles define rules to which a STF file adheres to. Each STF implementation has to check each file on import and export whether it adheres to its set profiles.

STF implementations can require some profiles in order to parse an STF asset. For example, game-engines may not support certain features, and as such can impose adherence to certain profiles.

STF defines a set of profiles, but implementations can define additional ones.

[]
* node_names_not_empty
Node names must contain more than zero non-whitespace characters.

* node_names_unique_within_prefab
Within a Scene Hierarchy, Node names must be unique, and contain more than zero non-whitespace characters. This condition is required by Blender.

* node_names_max_bytes_63
Node names can't be longer than 63 bytes. This condition is required by Blender.

* mesh_max_4_weights
Vertices in a mesh may have a maximum of 4 weights.

* mesh_max_8_weights
Vertices in a mesh may have a maximum of 8 weights.

* mesh_max_8_uv_channels
Vertices in a mesh may have a maximum of 4 weights.

* mesh_instances_separate
Instances of meshes must be the only component on that node.

* precision_32_bit_only
Buffers that get parsed by an STF implementation itself can only store 32 bit integers and floats. This includes buffers for vertices, normals or UVs. Buffers that store another fileformat, like PNG or JPG, do not matter for this rule.

* no_prefab_instances
Prefab instances are forbidden in this asset.

* self_contained
This file has no references to other files.

* compatibility_game_engine
This profile applies the conditions of: `mesh_max_8_weights`, `mesh_instances_separate`, `node_names_not_empty`, `precision_32_bit_only`.

* compatibility_game_engine_wide
This profile applies the conditions of: `mesh_max_4_weights`, `mesh_instances_separate`, `node_names_not_empty`, `precision_32_bit_only`.

* compatibility
This profile applies the conditions of: `mesh_max_8_weights`, `node_names_unique_within_prefab`, `node_names_max_bytes_63`, `mesh_max_8_uv_channels`, `mesh_instances_separate`, `precision_32_bit_only`.

* compatibility_wide
This profile applies the conditions of: `mesh_max_4_weights`, `node_names_unique_within_prefab`, `node_names_max_bytes_63`, `mesh_max_8_uv_channels`, `mesh_instances_separate`, `precision_32_bit_only`.


== Default Resource Types
These resource-types have to be supported by every STF implementation.

=== Data Resources
==== stf.mesh

==== stf.image

==== stf.material

==== stf.animation

=== Data & Scene Hierarchy Resources
==== stf.armature

=== Hierarchy Resources
==== stf.prefab
A prefab represents a hierarchy of nodes. It can be instantiated on another prefab's node. It can never be instantiated recursively or in a loop.

.stf.prefab properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|root |Yes |ID |ID of the root node within this prefab.
|nodes |Yes |Object of ID - node pairs |Nodes must represent a scene hierarchy object.
|===

The only allowed type for nodes contained in `stf.prefab` is `stf.node.spatial`.

Nodes are implicitly of the `stf.node.spatial` type, unless otherwise specified. Nodes also have an implicit boolean `enabled` property with a default value of `true`.

=== Node Resources
==== stf.node.spatial
A node that exists in 3d space. It defines its location, rotation and scale relative to its parent.

.stf.node.spatial properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|trs |Yes |TRS array |The nodes 3D transform
|children |No |Array of IDs |This child-nodes IDs
|components |No |Object of ID - 'Component' kind pairs |Components represent define functionality of a node.
|===

=== Component Resources
==== stf.instance.mesh

==== stf.instance.armature

==== stf.instance.prefab
An instance of a prefab. Optionally it applies a set of modifications on to the prefab it references. The referenced prefab may be from another file.

.stf.instance.prefab properties
[%autowidth, %header,cols=4*]
|===
|Key |Required |Type |Description

|target |Yes |ID |ID of the base prefab.
|modifications |Yes |Array of 'Modification' kinds |
|===

==== stf.texture

=== Modification Types
==== stf.modification.set_property

==== stf.modification.collection_append

==== stf.modification.append_node

==== stf.modification.add_component

==== stf.modification.remove_component
